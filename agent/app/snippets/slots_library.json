{
  "marks.bar.grouped": "cats = sorted(df[overlay['x']].dropna().unique()); groups = sorted(df[overlay.get('group')].dropna().unique()) if overlay.get('group') else [None]; width = overlay.get('style', {}).get('width', 0.8); alpha = overlay.get('style', {}).get('alpha', 0.9); arts = [];\nif groups == [None]:\n    values = [float(df[df[overlay['x']] == cat][overlay['y']].sum()) for cat in cats]\n    bars = ax.bar(cats, values, width=width, alpha=alpha)\n    arts.extend(bars)\nelse:\n    step = width / max(1, len(groups))\n    for idx, grp in enumerate(groups):\n        sub = df[df[overlay['group']] == grp]\n        xs = np.arange(len(cats)) + idx * step\n        vals = [float(sub[sub[overlay['x']] == cat][overlay['y']].sum()) for cat in cats]\n        bars = ax.bar(xs, vals, width=step, alpha=alpha, label=str(grp))\n        arts.extend(bars)\n    ax.set_xticks(np.arange(len(cats)) + width / 2)\n    ax.set_xticklabels([str(c) for c in cats])\nreturn arts",
  "marks.bar.stacked": "cats = sorted(df[overlay['x']].dropna().unique()); groups = sorted(df[overlay.get('group')].dropna().unique()) if overlay.get('group') else [None]; base = np.zeros(len(cats)); arts = [];\nfor grp in groups:\n    sub = df[df[overlay['group']] == grp] if grp is not None else df\n    vals = np.array([float(sub[sub[overlay['x']] == cat][overlay['y']].sum()) for cat in cats])\n    bars = ax.bar(cats, vals, bottom=base, alpha=overlay.get('style', {}).get('alpha', 0.9), label=str(grp) if grp is not None else None)\n    arts.extend(bars)\n    base += vals\nreturn arts",
  "marks.scatter.main": "x_codes, categories = _cat_codes(df[overlay['x']]); size = overlay.get('style', {}).get('size', 36); alpha = overlay.get('style', {}).get('alpha', 0.85); marker = overlay.get('style', {}).get('marker', 'o'); sc = ax.scatter(x_codes, df[overlay['y']], s=size, alpha=alpha, marker=marker, label=overlay.get('label', overlay.get('group'))); ax.set_xticks(np.arange(len(categories))); ax.set_xticklabels([str(c) for c in categories]); return [sc]",
  "marks.line.ci": "group = overlay.get('group'); alpha = overlay.get('style', {}).get('alpha', 0.2);\nif group and group in df:\n    for key, sub in df.groupby(group):\n        if overlay['x'] not in sub or overlay['y'] not in sub:\n            continue\n        ordered = sub.sort_values(overlay['x'])\n        if 'ci_low' in ordered and 'ci_high' in ordered:\n            ax.fill_between(ordered[overlay['x']], ordered['ci_low'], ordered['ci_high'], alpha=alpha, label=None)\nreturn []",
  "marks.line.error": "if 'yerr' in df:\n    ax.errorbar(df[overlay['x']], df[overlay['y']], yerr=df['yerr'], fmt='o-', alpha=overlay.get('style', {}).get('alpha', 0.9))\nreturn []",
  "marks.area.fill": "ordered = df.sort_values(overlay['x']); fill = ax.fill_between(ordered[overlay['x']], 0, ordered[overlay['y']], alpha=overlay.get('style', {}).get('alpha', 0.4)); return [fill]",
  "marks.hist.main": "values = df[overlay['y']].dropna().to_numpy(dtype=float); bins = overlay.get('style', {}).get('bins', 20); hist = ax.hist(values, bins=bins, alpha=overlay.get('style', {}).get('alpha', 0.9)); return [hist]",
  "marks.heatmap.main": "rows = overlay.get('x'); cols = overlay.get('group') or overlay.get('series'); val = overlay.get('y'); pivot = df.pivot_table(index=rows, columns=cols, values=val, aggfunc='mean', fill_value=0.0); im = ax.imshow(pivot.values, aspect='auto', cmap=overlay.get('style', {}).get('cmap', 'viridis')); ax.set_xticks(np.arange(len(pivot.columns))); ax.set_xticklabels([str(c) for c in pivot.columns], rotation=45, ha='right'); ax.set_yticks(np.arange(len(pivot.index))); ax.set_yticklabels([str(r) for r in pivot.index]); return [im]",
  "colorbar.apply": "if not ax_right:\n    image = ax_left.images[0] if ax_left.images else None\n    if image is not None:\n        fig.colorbar(image, ax=ax_left, fraction=0.05, pad=0.02)",
  "axes.ticks": "from matplotlib.ticker import MaxNLocator; ax_left.xaxis.set_major_locator(MaxNLocator(6)); ax_left.yaxis.set_major_locator(MaxNLocator(6));\nif ax_right: ax_right.yaxis.set_major_locator(MaxNLocator(6))",
  "axes.formatter": "ax_left.yaxis.set_major_formatter(_si(''));\nif ax_right: ax_right.yaxis.set_major_formatter(_si(''))",
  "axes.labels": "overlay0 = (spec.get('overlays') or [{}])[0]; ax_left.set_xlabel(overlay0.get('x', '')); ax_left.set_ylabel(overlay0.get('y', '')); title = ((spec.get('layout') or {}).get('titles') or {}).get('top');\nif title: ax_left.set_title(title, loc=(spec.get('layout') or {}).get('title_align', 'left'))",
  "legend.apply": "layout = spec.get('layout') or {}; cfg = layout.get('legend', {});\nif cfg.get('loc', 'best') == 'none':\n    return\nhandles, labels = ax_left.get_legend_handles_labels();\nif ax_right:\n    h2, l2 = ax_right.get_legend_handles_labels();\n    handles += h2; labels += l2\nif handles:\n    ax_left.legend(handles, labels, loc=cfg.get('loc', 'best'), frameon=False)",
  "grid.apply": "ax_left.grid(True, axis='y', alpha=0.3);\nif ax_right: ax_right.grid(False)",
  "annot.reference_lines": "for ref in (spec.get('annotations') or {}).get('reference_lines', []):\n    axis = ax_right if ref.get('axis', 'left') == 'right' and ax_right else ax_left\n    value = ref.get('value')\n    if value is not None:\n        axis.axhline(value, linestyle=ref.get('linestyle', '--'), linewidth=ref.get('linewidth', 1.0), color=ref.get('color', 'k'), alpha=ref.get('alpha', 0.7))",
  "scales.y_right.kind": "if ax_right and ((spec.get('scales') or {}).get('y_right') or {}).get('kind') == 'log':\n    ax_right.set_yscale('log')",
  "scales.y_left.breaks": "breaks = ((spec.get('scales') or {}).get('y_left') or {}).get('breaks');\nif breaks:\n    for lo, hi in breaks:\n        ax_left.axhspan(lo, hi, facecolor='white', alpha=1.0, zorder=5)"
}